q
c
display move
display @board
c
display move
display @board
@board
c
display @board
c
display @board
c
display @board
c
display @board
c
display @board
c
display @board
c
display @board
c
display @board
q
forward_slash[0][winning_move[2]]
forward_slash[0]
forward_slash
sets[3]
sets[2]
sets[1]
sets[0]
sets
winning_move
q
@board
self
winning_move
q
@board
self
winning_move
c
self
@board
@winning_move
winning_move
q
@board
sets.each_with_index { |set,i| set.each_with_index { |row, idx| p row.find_index(nil) if row.count(self.mark) == 2 && row.include?(nil) } }
sets.each_with_index { |set,i| set.each_with_index { |row, idx| p idx if row.count(self.mark) == 2 && row.include?(nil) } }
sets.each_with_index { |set,i| set.each_with_index { |row, idx| p i if row.count(self.mark) == 2 && row.include?(nil) } }
sets.each_with_index { |set,i| set.each_with_index { |row, idx| p i + idx if row.count(self.mark) == 2 && row.include?(nil) } }
sets.each { |set| set.each_with_index { |row, idx| p idx if row.count(self.mark) == 2 && row.include?(nil) } }
sets.each { |set| set.each_with_index { |row| p row if row.count(self.mark) == 2 && row.include?(nil) } }
sets.each { |set| set.each { |row| p row if row.count(self.mark) == 2 && row.include?(nil) } }
self
sets.each { |set| set.each { |row| p row } }
sets.each { |set| set.each { |row| p row }
sets
sets.each { |set| p set }
var local
q
n
@board
q
c
display location
c
mark
location
q
@board
@winning_move
q
@board
@winning_move
q
@winning_move
q
c
@board
can_win?
c
can_win?
c
can_win?
q
@board.over? { |r| r.uniq.length == 2 && r.include?(self.mark) && r.include?(nil) }
can_win?
c
display @board
q
c
display @board
q
@board.over? { |r| r.uniq.length == 2 && r.include?(self.mark) && r.include?(nil) }
can_win?
self
c
self
c
display @board
q
self.mark
self
@self
@mark
var all
c
@board
c
@board
c
q
c
location
s
move
s
@board
c
location
s
c
s
c
n
s
c
s
n
s
display move
c
move
c
move
c
move
c
move
c
move
c
move
c
move
q
c
display @board
c
display @board
c
@board.empty?([0,2])
@board.empty?([0,1])
@board
c
q
@board.empty?([1,1])
@board.empty?([1,0])
@board.empty
c
q
@board.empty?([2,2])
@board.empty?([2,1])
@board
c
q
@board.empty?([2, 2])
@board
c
q
@board.empty?([2, 1])
display @board
c
q
@board.empty?([0, 0])
@board.empty?[0, 0]
c
display @board
@board
q
@board.empty?([0, 2])
@board.empty?[0, 2]
c
display @board
@board
c
@board
c
@board
q
@board.grid
@board.grid[0][0] = :X
@board
@board.grid[0][0] = :X
@board
q
@board
@board.grid
@board.grid[0][0] = :X
@board.grid
@board
q
@board.dup
@board.grid
@board.grid[0]
q
@board.grid[0]
@board.grid
q
@board.grid
c
q
Marshal
Marhsal
@board.grid
@board
@grid
q
c
n
c
@board
@board.grid[0][1] = :X
@board.grid
@board
var instance
var local
q
grid.any? { |r| r.uniq.length == 1 }
@grid
forward_slash.any? { |r| r.uniq.length == 1 }
forward_slash
back_slash
q
@grid
back_slash
forward_slash
q
@grid[0, 4]
@grid[0, 3]
@grid[0, 2]
@grid[0, 1]
@grid[0]
@grid
@grid[1, 1]
@grid[0, 0]
@grid
forward_slash
back_slash
q
@grid
back_slash
q
